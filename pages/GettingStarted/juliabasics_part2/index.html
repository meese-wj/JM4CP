<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/JM4CP/libs/highlight/styles/github.min.css"> <link href="/JM4CP/css/franklin.css" rel=stylesheet > <link href="/JM4CP/css/vela.css" rel=stylesheet > <script src="/JM4CP/libs/vela/jquery.min.js"></script> <link href="http://fonts.cdnfonts.com/css/montserrat" rel=stylesheet > <link rel=icon  href="/JM4CP/assets/favicon.png"> <title>Julian Methods for Computational Physics</title> <div class="main-nav slideout-menu slideout-menu-left" id=menu > <div class=flex-container > <span class=sidebar-brand > <h3 style='font-size: 30px'><a href="/JM4CP/">JM4CP</a></h3> </span> </div> <nav class=sidebar-nav > <ul class=metismenu  id=metismenu  > <li><a href="/JM4CP/index.html">Home</a> <li><a href="" class=has-arrow >Getting Started</a> <ul> <li><a href="/JM4CP/pages/GettingStarted/gettingstarted">Tutorial Home</a> <li><a href="/JM4CP/pages/GettingStarted/installation">Installation Instructions</a> <li><a href="/JM4CP/pages/GettingStarted/pkg">using Pkg</a> <li><a href="/JM4CP/pages/GettingStarted/juliabasics_part1">Julia Basics I</a> <li><a href="/JM4CP/pages/GettingStarted/juliabasics_part2">Julia Basics II</a> </ul> <li><a href="/JM4CP/pages/helpful_resources">Helpful Resources</a> </ul> </nav> </div> <main id=panel  class="slidout-panel slideout-panel-left"> <div class="toggle-button hamburger hamburger--spin"> <div class=hamburger-box > <div class=hamburger-inner ></div> </div> </div> <h1 class="page title">Julia Basics II</h1> <hr> <div class=franklin-content ><h1 id=the_programmatic_minimum ><a href="#the_programmatic_minimum" class=header-anchor >The Programmatic Minimum</a></h1> <h2 id=whats_in_this_tutorial ><a href="#whats_in_this_tutorial" class=header-anchor >What&#39;s in this tutorial?</a></h2> <h2> <p> <em><strong>First Posted:</strong> August 9, 2022</em> </p> <p> <em><strong>Last Updated:</strong> August 27, 2022</em> </p> </h2> <div class=franklin-toc ><ol><li><a href="#whats_in_this_tutorial">What&#39;s in this tutorial?</a><li><a href="#basic_build_blocks">Basic build blocks</a><ol><li><a href="#functions_methods">Functions &amp; Methods</a><li><a href="#variables">Variables</a><li><a href="#scopes">Scopes</a><ol><li><a href="#the_global_scope">The Global Scope</a><li><a href="#the_local_scope">The Local Scope</a></ol></ol><li><a href="#helpful_built-in_types">Helpful built-in types</a><ol><li><a href="#strings">Strings</a><li><a href="#arrays_matrices_and_vectors">Arrays, Matrices, and Vectors</a><li><a href="#tuples">Tuples</a><li><a href="#named-tuples_and_dictionaries">Named-Tuples and Dictionaries</a></ol><li><a href="#user-defined_types_structs">User-defined types: structs</a><ol><li><a href="#mutability">Mutability</a></ol><li><a href="#built-in_macros">Built-in macros</a><li><a href="#is_julia_a_statically-typed_language">Is Julia a statically-typed language?</a></ol></div> <h2 id=basic_build_blocks ><a href="#basic_build_blocks" class=header-anchor >Basic build blocks</a></h2> <p>In this section, we&#39;ll discuss the basics of how to get Julia code up and running.</p> <h3 id=functions_methods ><a href="#functions_methods" class=header-anchor >Functions &amp; Methods</a></h3> <p>We start with the primary datatype in Julia: function methods. As described in the <a href="/JM4CP/pages/GettingStarted/juliabasics_part1">previous tutorial</a>, Julia revolves around <code>function</code>s which are <strong>abstract</strong>, and <code>methods</code> which are <strong>concrete</strong>. In other words, whenever one implements a particular <code>function</code> for a <strong>specific</strong> set of argument <code>Type</code>s, then it is referred to as a <code>method</code> of that <code>function</code>.</p> <p>Method definitions are beautifully simple in Julia. For example, they can be written as</p> <pre><code class="julia hljs">line(x, m, b) = m * x + b</code></pre>
<p>for a <code>function</code> <code>line</code> which computes the value of a line given some arguments. In this <code>method</code> definition, <code>line</code> takes in the arguments <code>&#40;x, m, b&#41;</code>.</p>
<p>In the <code>REPL</code>, go ahead and copy-and-paste <code>line</code> into the command line and hit <code>Enter</code>. You should see the following output:</p>
<div class=code-output ><pre><code class="plaintext hljs">line (generic function with 1 method)</code></pre></div>
<p>Here we see that <code>line</code> has one method. We can use that one method to do calculations, for example as</p>
<pre><code class="julia hljs"><span class=hljs-meta >@show</span> line(<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>)</code></pre>
<div class=code-output ><pre><code class="plaintext hljs">line(1, 2, 3) = 5
</code></pre></div>
<p>Now, let&#39;s add <code>::Vector</code> to the <code>x</code> argument and change up the definition a bit. &#40;The <code>::</code> flag is how one can specify type information in Julia.&#41;</p>
<pre><code class="julia hljs">line(x::<span class=hljs-built_in >Vector</span>, m, b) = m .* x .+ b</code></pre>
<p>Here, the <code>.</code> in front of the <code>*</code> and <code>&#43;</code> operators <em>vectorize</em> your code and simply mean &quot;apply this operation to each element&quot; and so it inherently implies the use of a loop over all elements of <code>x</code> for the multiplication first, and then again over all elements of the <code>Vector</code> <code>m .* x</code> for the addition. All it cost us is a replacement of <code>*</code> and <code>&#43;</code> by <code>.*</code> and <code>.&#43;</code>. Not too shabby&#33; </p>
<p>Now, let&#39;s check <code>methods</code> again to verify that our <code>line</code> was overwritten:</p>
<pre><code class="julia hljs">methods(line)</code></pre>
<div class=code-output ><pre><code class="plaintext hljs"># 2 methods for generic function &quot;line&quot;:
[1] line(x::Vector, m, b) in Main.FD_SANDBOX_2950733204805230011 at none:1
[2] line(x, m, b) in Main.FD_SANDBOX_2950733204805230011 at none:1</code></pre></div>
<p>As you can see, our original <code>line</code> method was not overwritten, but <em>overloaded</em>. Now this <code>line</code> has <em>two</em> distinct methods, one where the <code>x</code> argument is a <code>Vector</code>, and one where it is not. By default, if no type information is supplied to the arguments, they are <em>inferred</em> by Julia to be the type <code>Any</code> which is the supertype of all other types. So it literally could represent <em>anything</em>. </p>
<p>So which method will be called in the following cases?</p>
<pre><code class="julia hljs"><span class=hljs-meta >@show</span> line(<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>)
<span class=hljs-meta >@show</span> line([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>], <span class=hljs-number >2</span>, <span class=hljs-number >3</span>)</code></pre>
<div class=code-output ><pre><code class="plaintext hljs">line(1, 2, 3) = 5
line([1, 2, 3], 2, 3) = [5, 7, 9]
</code></pre></div>
<p>&#40;As will be talked about <a href="#arrays_matrices_and_vectors">later in this tutorial</a>, one can create a column in Julia <code>Vector</code> of type <code>Int</code> by writing <code>&#91;1, 2, 3&#93;</code>.&#41; Notice how the first example returns the same result from before, whereas the second returns the column vector resulting from our <code>line</code> method with the <code>Vector</code> first argument.</p>
<p>What does this mean? It means that Julia is smart enough to call the appropriate method of a <code>function</code> for its supplied argument types. Furthermore, it shows that because methods with more specific argument types are preferred over those with more general argument types. Otherwise, the <code>m * x &#43; b</code> method <em>should</em> have been called &#40;and subsequently then thrown an error&#41; for our <code>Vector</code> argument rather than the correct <code>m .* x .&#43; b</code> one. Indeed, the ordered set of most specific type arguments of a method uniquely identify it. Therefore, methods will only be <strong>overwritten</strong> if <strong>all</strong> arguments are specified exactly the same way. Otherwise, Julia makes a new method for the new argument types, and then use its own 
    <a href=" https://en.wikipedia.org/wiki/Multiple_dispatch?oldformat=true" target=_blank > multiple dispatch</a>
     system to choose the right one. Behold the power&#33;</p>
<p>But, with great power comes great responsibility: sometimes we can accidentally creat what are called <em>method ambiguities</em>. For example, suppose we want the slopes <code>m</code> always to be of type <code>Float64</code>. We can do this by writing</p>
<pre><code class="julia hljs">line(x, m::<span class=hljs-built_in >Float64</span>, b) = m .* x .+ b</code></pre>
<p>Then, we call <code>methods</code> again and see</p>
<pre><code class="julia hljs">methods(line)</code></pre>
<div class=code-output ><pre><code class="plaintext hljs"># 3 methods for generic function &quot;line&quot;:
[1] line(x::Vector, m, b) in Main.FD_SANDBOX_2950733204805230011 at none:1
[2] line(x, m::Float64, b) in Main.FD_SANDBOX_2950733204805230011 at none:1
[3] line(x, m, b) in Main.FD_SANDBOX_2950733204805230011 at none:1</code></pre></div>
<p>meaning that we have successfully added a third method for <code>line</code>. Or have we? Because if we call <code>line&#40;&#91;1, 2, 3&#93;, 2.0, 3&#41;</code>, we now see an error:</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > line([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>], <span class=hljs-number >2.0</span>, <span class=hljs-number >3</span>)
</span>ERROR: MethodError: line(::Vector{Int64}, ::Float64, ::Int64) is ambiguous.</code></pre>
<p>As the rest of the error message shows, this is because Julia isn&#39;t sure whether to call the method that specializes the <code>x</code> argument from <code>Any</code> to <code>Vector</code>, or to call the method that specializes the <code>m</code> argument from <code>Any</code> to <code>Float64</code>. As Julia should suggest:</p>
<pre><code class="julia-repl hljs">Possible fix, define
  line(::Vector, ::Float64, ::Any)</code></pre>
<p>So all we would need to do is define, yet another, method to tell Julia specifically what we need it to do:</p>
<pre><code class="julia hljs">line(x::<span class=hljs-built_in >Vector</span>, m::<span class=hljs-built_in >Float64</span>, b) = m .* x .+ b

methods(line)</code></pre>
<div class=code-output ><pre><code class="plaintext hljs"># 4 methods for generic function &quot;line&quot;:
[1] line(x::Vector, m::Float64, b) in Main.FD_SANDBOX_2950733204805230011 at none:1
[2] line(x::Vector, m, b) in Main.FD_SANDBOX_2950733204805230011 at none:1
[3] line(x, m::Float64, b) in Main.FD_SANDBOX_2950733204805230011 at none:1
[4] line(x, m, b) in Main.FD_SANDBOX_2950733204805230011 at none:1</code></pre></div>
<p>giving us four methods in total. Now by calling that last line that threw an error, we see that everything is fixed and we get the correct result.</p>
<pre><code class="julia hljs"><span class=hljs-meta >@show</span> line([<span class=hljs-number >1</span>, <span class=hljs-number >2</span>, <span class=hljs-number >3</span>], <span class=hljs-number >2.0</span>, <span class=hljs-number >3</span>)</code></pre>
<div class=code-output ><pre><code class="plaintext hljs">line([1, 2, 3], 2.0, 3) = [5.0, 7.0, 9.0]
</code></pre></div>
<p>That about wraps things up for functions. The last thing I want to point out is that there are actually a couple of more ways to create new functions. The first uses a <code>begin ... end</code> block allowing one to have multiple lines, like so</p>
<pre><code class="julia hljs">line(x, m, b) = <span class=hljs-keyword >begin</span>
    result = m * x
    result += b
    <span class=hljs-keyword >return</span> result
<span class=hljs-keyword >end</span></code></pre>
<p>or one can use the <code>function ... end</code> block which is the more normal way to have multiple-line functions in Julia:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> line(x, m, b)
    result = m * x
    result += b
    <span class=hljs-keyword >return</span> result
<span class=hljs-keyword >end</span></code></pre>
<p>With either of these two methods &#40;ðŸ˜‰&#41;, one can then have arbitrarily many lines in functions as one then pleases. But, as is true for all programming, it is considered good practice to have very small functions that all do very specific things, then then to stitch them together to make more complicated code.</p>
<div class=codeinfo ><div class=title >âš  Code Info</div>
<div class=content ><p>Notice that in these last multi-line function method definitions, that we used the keyword <code>return</code>. This is not necessary for Julia, unlike languages like Python and C&#43;&#43;. &#40;In Python and C&#43;&#43;, a lack of a return keyword implies the function returns <code>nothing</code> or is <code>void</code>, respectively.&#41;</p>
<p>We could have just left the final lines as <code>result &#43;&#61; b</code>, because this on its own returns <code>result</code>. Generally, Julia will return the output from the last line of any function, and so sometimes people would write the last example as:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> line(x, m, b)
    result = m * x
    result += b
<span class=hljs-keyword >end</span></code></pre>
<p>I personally like to keep the <code>return</code> keyword there for two reasons. First, sometimes it isn&#39;t possible to write functions without them, as is the case with branching functions, <em>etc</em>. Secondly, I like verbose, readable code. I don&#39;t like having to out-smart the code. I prefer when it tells me <em>exactly</em> what it is trying to do.</p></div></div>
<h3 id=variables ><a href="#variables" class=header-anchor >Variables</a></h3>
<p>Functions and their methods are only really useful if we&#39;re able to store their results somewhere. And where do we do this? In variables&#33;</p>
<p>To define a variable in Julia, like most other languages that I know of, the name is written relative to the equals sign <code>&#61;</code> which translates to <em>assignment</em> rather than <em>equals</em> like it does in mathematics. For example, if we want to store the value <code>4</code> in a variable named <code>thing</code>, then we would do so by writing</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > thing = <span class=hljs-number >4</span>
</span>4</code></pre>
<p>This contrasts with</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-number >4</span> = thing
</span>ERROR: syntax: invalid assignment location &quot;4&quot;</code></pre>
<p>which <em>should</em> be allowed mathematically, but is not allowed syntactically.</p>
<p>Other than that, there is not much else to variables. They can be named whatever you like, other than Julia keywords like <code>function</code>, <code>for</code>, <code>if</code>, <em>etc.</em></p>
<p>The final piece I want to say, however, is that variables, like in Python, are just labels. They generally do not actually represent data; rather they <em>point</em> to data. This is particularly meaningful for people coming to Julia from the world of C, C&#43;&#43;, and Fortran, where variables represent actual data. This means that when variables are passed around, say to function methods as arguments, then it is <strong>cheap</strong> in Julia &#40;as cheap as throwing around an integer&#41;.</p>
<p>This is identical to Python, but it contrasts with C and C&#43;&#43; in particular where variables are passed around and <em>copied</em> into functions by default. Thus, in Julia there is nothing from stopping any function from modifying the underlying data <em>pointed to</em> by any of its arguments at any time. Meanwhile, in C/C&#43;&#43;, a function would be modifying the <em>copy</em> of the underlying data rather than the original. There are exceptions to this rule in Julia, though: 
    <a href=" https://docs.julialang.org/en/v1/manual/types/#Primitive-Types" target=_blank > primitive types</a>
     like <code>Int</code>s and <code>Float</code>s or im<code>mutable</code> types cannot and will not be modified, <em>ever</em>. Any other variable representing more complicated types, like <code>Vector</code>s which are <code>mutable</code>, will never actually <em>be</em> the values they point to, but will rather be just labels pointing to their values.</p>
<p>That is as much as I want to go into these details at this point. This is a tutorial after all&#33; And too many initial details can always be overwhelming. But I did want to say just a bit so it&#39;s always in the back of your mind.</p>
<h3 id=scopes ><a href="#scopes" class=header-anchor >Scopes</a></h3>
<p>Before diving into the details about specific types and how to use them, we should first discuss 
    <a href=" https://docs.julialang.org/en/v1/manual/variables-and-scoping/" target=_blank > scopes.</a>
     These <em>regions of code</em> represent where particular variables can be accessed and used.</p>
<p>There are a few important scopes to keep in mind when just starting to code:</p>
<h4 id=the_global_scope ><a href="#the_global_scope" class=header-anchor >The Global Scope</a></h4>
<p>Any variable written outside of <code>function</code>s, <code>struct</code>s, <code>let</code>s, <code>macro</code>s, <code>module</code>s, <em>etc.</em> , lives in the global scope and can be accessed by any other part of your code at any time &#40;assuming what is requesting access knows that the variable has been defined before the call&#41;. All variables defined in the <code>REPL</code> are in the global scope. </p>
<p>I want to emphasize early on that it is generally considered bad form to write functions that depend on global variables. This is because, as mentioned in <a href="#variables">Variables</a>, variables are only labels that represent data, but they themselves are <strong>not</strong> the underlying data. So the actual data pointed to by any global variable, and more importantly its <code>Type</code>, at any time can change. The Julia compiler cannot know in advance how to handle this, and it in turn writes pretty slow code to handle the task in the most generic way it can. This problem is avoided, however, if one defines a global variable <code>const</code>, for instance in a function that <code>exp</code>onentiates like in the following example</p>
<pre><code class="julia hljs"><span class=hljs-keyword >const</span> im_a_performant_global = <span class=hljs-number >4</span>

my_performant_function(x) = exp( x * im_a_performant_global )</code></pre>
<p>which will be performant because we promised the compiler that the global <code>im_a_performant_global</code> will never change, so its <code>Type</code> never will either.</p>
<div class=codeinfo ><div class=title >âš  Code Info</div>
<div class=content ><p>To see just how much slower non-<code>const</code> globals can be, we can use the <code>BenchmarkTools</code> package in the standard library to accurately measure the performance between the two cases. First, we must <a href="/JM4CP/pages/GettingStarted/pkg"><code>Pkg.add</code></a> it to our environment like</p>
<pre><code class="julia-repl hljs"><span class=hljs-metap>(my_environment) pkg&gt;</span> add BenchmarkTools</code></pre>
<p>and use it in our code like</p>
<pre><code class="julia-repl hljs"><span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> BenchmarkTools</span></code></pre>
<p>Then we will use its <code>@btime</code> macro to help us test the performance.</p>
<p>We define a slow global</p>
<pre><code class="julia hljs">im_not_a_performant_global = <span class=hljs-number >4</span>

my_slow_function(x) = exp( x * im_not_a_performant_global )</code></pre>
<p>and then benchmark both when <code>y &#61; 1.0</code>. In order to properly use this <code>macro</code>, we must <em>interpolate</em> the variable <code>y</code> into our expression using the <code>&#36;</code> symbol.</p>
<pre><code class="julia hljs">y = <span class=hljs-number >1.0</span>

<span class=hljs-meta >@btime</span> my_performant_function($y)</code></pre>
<div class=code-output ><pre><code class="plaintext hljs">  7.000 ns (0 allocations: 0 bytes)
54.598150033144236</code></pre></div>
<pre><code class="julia hljs"><span class=hljs-meta >@btime</span> my_slow_function($y)</code></pre>
<div class=code-output ><pre><code class="plaintext hljs">  51.064 ns (3 allocations: 48 bytes)
54.598150033144236</code></pre></div>
<p>So, as we can see, the use of the <code>const</code> keyword improves the performance of global variables by almost an order of magnitude&#33; Also, the <code>@btime</code> macro shows us the number of allocations made. In the performant case, there are zero, but in the slow case, there are several. This again shows the fact that the Julia compiler is writing generic code, and since the <code>typeof&#40;im_not_a_performant_global&#41;</code> can change, Julia makes slow heap allocations to be as general as possible.</p>
<p>The takeaway is that if you <strong>need</strong> to use a global and you <strong>need</strong> speed, use <code>const</code>s.</p></div></div>
<h4 id=the_local_scope ><a href="#the_local_scope" class=header-anchor >The Local Scope</a></h4>
<p>Local scopes are created basically inside any type of 
    <a href=" https://docs.julialang.org/en/v1/manual/variables-and-scoping/#man-scope-table" target=_blank > code block</a>
     in Julia. These scopes are wiped clean once they complete their lifecycle, and any variables defined inside them are completely inaccessible to parts of code outside of them. For example, the following snippet throws an error when we try to assign the local variable <code>x</code> to the global variable <code>y</code>:</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> this_defines_a_local(z)
    x = z
    <span class=hljs-keyword >return</span> <span class=hljs-literal >nothing</span>
<span class=hljs-keyword >end</span>

zval = <span class=hljs-number >42</span>
this_defines_a_local(zval)

y = x  <span class=hljs-comment ># Errors because x is undefined outside of the local scope</span></code></pre>
<p>Unlike global scopes, the Julia compiler <em>loves</em> local variables. This is because it knows in almost every case all the details about the variables&#39; <code>Type</code> information. So it doesn&#39;t need to be weary of any surprises, and it can optimize as much as possible.</p>
<p>I want to point out that in the example above, the argument variable <code>z</code> is actually a <em>local</em> even though <code>zval &#61; 42</code> is passed into it. What happens in these cases, since variables are just labels, is that a local copy of the label is created which points to the same data in memory. Then that new local label is used to access the data. When the function ends, then the local label is destroyed, but not the data it points to&#33;</p>
<p>There are some more technical details about local scopes that exist in Julia that I think are beyond the scope &#40;ðŸ˜Ž&#41; of this tutorial. For those interested, or for those unlucky enough to encounter a &quot;soft-scope&quot; error early on, I&#39;ll point you to 
    <a href=" https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Local-Scope" target=_blank > documentation</a>
     for more information.</p>
<p>This about covers what I think is the bare minimum to get started with writing Julia code. From here, we will talk about helpful built-in types and how to use them.</p>
<h2 id=helpful_built-in_types ><a href="#helpful_built-in_types" class=header-anchor >Helpful built-in types</a></h2>
<pre><code class="julia-repl hljs"><span class=hljs-metap>(v1.8) pkg&gt;</span> activate ./Universe

<span class=hljs-metap>(Universe) pkg&gt;</span>

<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > <span class=hljs-keyword >using</span> Universe
</span>
<span class="hljs-meta prompt_">julia&gt;</span><span class=language-julia > Universe.make_more_time()
</span>[Info: Processing request...
[Info: This may take a few moments.</code></pre>
<h3 id=strings ><a href="#strings" class=header-anchor >Strings</a></h3>
<h3 id=arrays_matrices_and_vectors ><a href="#arrays_matrices_and_vectors" class=header-anchor >Arrays, Matrices, and Vectors</a></h3>
<h3 id=tuples ><a href="#tuples" class=header-anchor >Tuples</a></h3>
<h3 id=named-tuples_and_dictionaries ><a href="#named-tuples_and_dictionaries" class=header-anchor >Named-Tuples and Dictionaries</a></h3>
<h2 id=user-defined_types_structs ><a href="#user-defined_types_structs" class=header-anchor >User-defined types: structs</a></h2>
<h3 id=mutability ><a href="#mutability" class=header-anchor >Mutability</a></h3>
<h2 id=built-in_macros ><a href="#built-in_macros" class=header-anchor >Built-in macros</a></h2>
<h2 id=is_julia_a_statically-typed_language ><a href="#is_julia_a_statically-typed_language" class=header-anchor >Is Julia a statically-typed language?</a></h2>
<div class=page-foot >
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> W. Joe Meese. Last modified: August 27, 2022.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>
</div>
  </main> 
  <script src="/JM4CP/libs/vela/metisMenu.min.js"></script>
  <script src="/JM4CP/libs/vela/slideout.min.js"></script>
  
  
    <script src="/JM4CP/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>